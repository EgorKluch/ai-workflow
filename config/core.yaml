# NOTE: Core processes intentionally do not have CRITICAL HELP CRITERION - this is an exception
# as core processes require autonomous operation without external clarification calls

core: 
  processes:
    clarifySession:
      purpose: "Resolve information gaps by first consulting user with clear questions, then executing targeted process iterations, and escalating only if automated resolution fails"
      prompt: |
        REQUIRED INPUT: Problem context describing specific uncertainty that triggered clarification need.
        
        Tasks: Analyze problem context → formulate user questions → present structured questions → process user responses → execute runIteration → evaluate results → escalate if needed
        
        User consultation: Ask specific questions explaining why information is needed and what decision depends on the answer. Provide concrete options when appropriate.
        
        Process execution: Select processes aligned with user guidance. Transform responses into actionable iteration context.
        
        HOW TO RESPOND (MAX 5 lines each):
        • **Uncertainty Identified**: Specific gap or ambiguity requiring clarification
        • **User Questions**: Clear, contextual questions with explanation of why information is needed
        • **User Guidance Received**: Summary of user responses and how they inform next steps
        • **Processes Executed**: Selected processes with rationale based on user guidance
        • **Resolution Status**: Whether uncertainty resolved or requires further user involvement

    planSessionIteration:
      purpose: "Analyze session state, detect critical blockers, and determine next workflow steps with comprehensive blocker resolution"
      prompt: |
        Tasks: Read session file → evaluate progress vs goal → detect critical blockers → classify blockers → determine next steps
        
        ENHANCED BLOCKER DETECTION (as SOLE blocker detection mechanism):
        1. Systematic Session Analysis: Parse all sections for potential blockers
        2. Cross-Reference Analysis: Check for conflicting information across sections  
        3. Implementation Readiness: Assess if sufficient information for implementation
        4. Risk Assessment: Identify high-risk decisions needing user input
        
        CRITICAL BLOCKER DETECTION:
        1. Scope Analysis: Check unresolved elements in blockers.needToUserApprove
        2. Requirement Conflicts: Find contradictory/ambiguous requirements
        3. Technical Dependencies: Find critical decisions without resolution
        4. Implementation Blockers: Find architectural/dependency issues
        
        BLOCKER CLASSIFICATION:
        • USER_DECISION_REQUIRED → blockers.needToUserApprove: business decisions, scope changes, architecture choices
        • CLARIFY_RESOLVABLE → blockers.needToClarify: technical details, non-critical ambiguities, process questions
        
        DECISION TREE:
        1. Goal Complete? → execute runSessionIteration({processes: ['qualityAssurance']})
        2. USER_DECISION_REQUIRED blockers? → Stop progress, request user decisions
        3. CLARIFY_RESOLVABLE blockers? → call clarifySession({context: blocker description})
        4. Information Missing? → call clarifySession({context: gap description})
        5. Information Sufficient? → execute runSessionIteration({processes: ['codeImplementation']})
        
        Available processes: {{AVAILABLE_PROCESSES}}
        
        HOW TO RESPOND (MAX 5 lines for each blocker):
        If blockers detected:
        • **Critical Blockers Detected**: [USER_DECISION_REQUIRED/CLARIFY_RESOLVABLE]
        • **Blocker Details**: Specific description of what needs resolution
        • **Business Impact**: Why this blocks progress and consequences
        • **Resolution Required**: What user needs to decide or what needs clarification
        • **Recommended Action**: Specific next step - user consultation or clarifySession call

    updateSession:
      purpose: "Actualize session content with automatic critical blocker detection, information prioritization, and structural guidance"
      prompt: |
        INFORMATION CLASSIFICATION FRAMEWORK:
        • IMMUTABLE (preserve exactly): immutable.* sections - never modify content, only expand
        • EVOLVING (update with current state): evolving.* sections - replace outdated content with current state
        • CONSOLIDATABLE (merge redundant content): consolidatable.* sections - merge repetitive content, eliminate duplications
        • EXPENDABLE (remove when obsolete): expendable.* sections - remove superseded or irrelevant content
        
        CRITICAL BLOCKER MANAGEMENT:
        When updating blockers section:
        • Move USER_DECISION_REQUIRED items to blockers.needToUserApprove with clear business impact
        • Move CLARIFY_RESOLVABLE items to blockers.needToClarify with context
        • Mark implementation steps as blocked if dependent on unresolved blockers
        • Preserve resolution requirements and add deadlines if time-sensitive
        
        ACTUALIZATION ALGORITHM:
        1. Read/analyze session file → assess current structure → identify classification needs
        2. Apply INFORMATION CLASSIFICATION → update EVOLVING content → preserve IMMUTABLE sections
        3. Consolidate CONSOLIDATABLE content → remove EXPENDABLE items → resolve contradictions
        4. Update blockers section with proper classification → mark blocked implementation steps
        5. Ensure YAML compliance and logical organization → SAVE file
        
        CONTRADICTION RESOLUTION: User decisions > technical assumptions, explicit > implicit, recent > old, scope > features, tested > theoretical
        
        MANDATORY: Use file tools to update and SAVE session file. Provide brief structural recommendations.
        
        HOW TO RESPOND (MAX 5 lines for each changed item):
        • **STRUCTURE APPLIED**: How session file was reorganized according to recommended structure
        • **IMMUTABLE PRESERVED**: [immutable.* sections preserved exactly]
        • **EVOLVING UPDATED**: [evolving.* sections updated with current state]  
        • **CONSOLIDATED**: [consolidatable.* sections merged and deduplicated]
        • **EXPENDABLE REMOVED**: [expendable.* obsolete content removed]
        • **BLOCKERS ORGANIZED**: [needToUserApprove and needToClarify items structured]
        • **RECOMMENDATIONS**: Brief guidance on session file organization and next steps

  templates:
    runSessionIteration:
      purpose: "Template for unified execution prompt generation"
      unifiedPromptHeader: "Execute the following processes in sequence:\n\n"
      processTemplate: |
        === PROCESS: {{PROCESS_NAME}} ===
        Purpose: {{PROCESS_PURPOSE}}

        {{PROCESS_PROMPT}}

        === END PROCESS: {{PROCESS_NAME}} ===

      responseRequirements: |
        CRITICAL RESPONSE REQUIREMENTS:
        - MUST follow each process's specific "HOW TO RESPOND" format exactly as specified
        - MUST use bullet points with markdown bold formatting: • **Field Name**: Content
        - MUST limit each response field to maximum 5 lines as specified
        - MUST provide structured, concise responses for each process
        - MUST complete all processes before proceeding to mandatory completion sequence

      contextGuidance: |
        CONTEXT GUIDANCE:
        {{CONTEXT}}

        Apply this context to refine your process execution for more precise results.

      mandatoryCompletion: |
        MANDATORY COMPLETION SEQUENCE:
        After completing all processes above:
        1. Call updateSession() to save your progress and findings
        2. After updateSession completion, call planSessionIteration() to determine next steps
        3. Follow the instructions returned by planSessionIteration

        This sequence ensures proper workflow continuation and context preservation.

    clarifySessionExtensions:
      purpose: "Template extensions for clarifySession prompt"
      contextSection: |
        PROBLEM CONTEXT PROVIDED: {{CONTEXT}}

        AVAILABLE PROCESSES FOR SELECTION:
        {{AVAILABLE_PROCESSES}}

        RESOLUTION ALGORITHM:
        1. Analyze the provided problem context to identify specific information gaps
        2. Select appropriate processes from the available list that can help resolve the uncertainty
        3. Validate that selected processes make logical sense for the problem context
        4. Call runSessionIteration with selected processes and transformed context
        5. If after iteration completion the problem is not resolved, explicitly request user help

        Remember: Transform the problem context into actionable iteration context that guides resolution. 